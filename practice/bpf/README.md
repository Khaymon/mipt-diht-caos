# Berkley Packet Filter

Основной класс задач, в которых применяется чтение из RAW-сокетов, - это мониторинг системы. При этом возникает проблема большого потока данных, который необходимо обрабатывать, и постоянное переключение контекста между выполнением кода в пространстве ядра и в пространстве пользователя существенно снижает производительность.

Поскольку принимать нужно не все пакеты, проходящие через сетевой интерфейс, а только те, которые соответствуют некоторым критериям, то логично перенести логику фильтрации в адресное пространство ядра, а затем получать от ядра только те пакеты, которые не отвергнуты фильтром.

В качестве примера использования можно рассмотреть утилиту `tcpdump`, которая принимает в качестве аргумента текстовую строку, описывающую функцию фильтрации, и отображает только те события, которые соответствуют фильтру. В своей реализации утилита `tcpdump` использует BPF.

Дополнительные материалы (English only):

* Документация из поставки ядра Linux: [Linux Socket Filtering aka Berkley Packet Filter (BPF)](https://github.com/torvalds/linux/blob/v5.6/Documentation/networking/filter.txt)
* [man 2 bpf ](http://man7.org/linux/man-pages/man2/bpf.2.html)
* [BPF and XDP Reference Guide](https://cilium.readthedocs.io/en/latest/bpf/#bpf-and-xdp-reference-guide)

## Классический BPF: Linux Socket Filter

### Мониторинг сети и задача фильтрации

Рассмотрим задачу фильрации пакетов на уровне Data Link Layer, и будем отлавливать те из них, которые соответствуют некоторому критерию. Для простоты можно рассмотреть IPv4/UDP-сообщения к определенному DNS-серверу, - такие запросы будет легко отлаживать.

Создадим Data-Link сокет, и свяжем его с определенным сетевым интерфейсом, например `eth0`:

```c
int sock = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL));

/* Не забываем проверять ошибки! Packet-сокет невозможно создать, 
не имея права root или настроенный CAP_NET_RAW */
if (-1==sock) { perror("socket"); exit(1); } 

/* Далее нужно связать сокет с определенным сетевым интерфейсом */
struct ifreq req;
memset(&req, 0, sizeof(req));
strncpy(req.ifr_name, "eth0", IFNAMSIZ);
ioctl(sock, SIOCGIFINDEX, &req, sizeof(req)); // определяем индекс eth0

/* Для Data-Link Layer нужно заполнить только часть полей адреса,
остальные должны быть инициализированы нулями */
struct sockaddr_ll addr;
memset(&addr, 0, sizeof(addr));
addr.sll_family = AF_PACKET;  // указываем, что структура для PACKET
addr.sll_protocol = htons(ETH_P_ALL);  // нас интересует только Ethernet
addr.sll_ifindex = req.ifr_ifindex; // индекс устройства (см. выше)

/* Привязываем сокет к определенному адресу. Если не вызывать bind,
то нужно использовать recvfrom и sendto с явным указанием адреса */
if (-1==bind(sock, (struct sockaddr*)&addr, sizeof(addr))) {
    perror("bind"); exit(1);
}
```

Теперь можно наблюдать за тем, что проходит через этот сетевой интерфейс.

```c
for (;;) {
    char buffer[4096];
    memset(buffer, 0, sizeof(buffer));
    
    /* Читаем блок данных из сетевого устройства */
    size_t cnt = recv(sock, buffer, sizeof(buffer), 0);

    uint32_t from_ip, to_ip;

    /* Извлекаем адреса источника и получателя из заголовка IPv4 */
    memcpy(&from_ip, buffer+26, sizeof(from_ip));
    memcpy(&to_ip, buffer+30, sizeof(to_ip));

    char from_addr[20], to_addr[20];
    memset(from_addr, 0, sizeof(from_addr));
    memset(to_addr, 0, sizeof(to_addr));
    inet_ntop(AF_INET, &from_ip, from_addr, sizeof(from_addr));
    inet_ntop(AF_INET, &to_ip, to_addr, sizeof(to_addr));

    printf("Got communication from %s to %s\n", from_addr, to_addr);
}
```

На реально используемой системе можно будет наблюдать огромное количество пакетов сетевого взаимодействия. 

### Виртуальная машина Classic-BPF

Программа фильтрации, загружаемая в ядро, состоит из набора 64-битных RISC-команд, которые выполняются виртуальной машиной, либо могут быть транслированы в нативный код. 

Каждая инструкция кодируется следующим образом:

```c
struct sock_filter {	
	__u16	code;   // 16 бит - код команды
	__u8	jt;		// 8 бит - смещение для true/jump-инструкций
	__u8	jf;	    // 8 бит - смещение для false/jump-инструкций
	__u32	k;      // 32 бит - поле для произвольных данных
};
```

У виртуальной машины есть только два 32-битных регистра: аккумулятор `A`, над которым можно выолнять произвольные действия, и счетчик инструкций `X`. Возможен доступ к "памяти", при этом адресуется содержимое исследуемого сетевого пакета.

Поскольку виртуальная машина была спроектирована по аналогии с реально существующим процессором Motorola 6502, то для этого набора команд существует язык ассемблера. Программная реализация ассемблера BPF находится в поставке исходных текстах ядра Linux: `tools/bpf/bpf_asm`. 

#### Команды ассемблера BPF

* Перемещение данных: 
  - загрузить в регистр `A`: `ld` - слово, `ldh` - полуслово, `ldb` - байт;
  - сохранить значение в памяти: `st` для регистра `A`, `stx` для регистра `X`;
  - перемещение между регистрами: `tax` - из `A` в `X`, `txa` - из `X` в `A`
* Арифметические операции над регистром `A`: `add`, `sub`, `mul`, `div`, `mod`, `neg`, `and`, `or`, `xor`, `lsh`, `rsh` 
* Переходы на метку:
  * `jmp` - безусловный переход;
  * `jeq`, `jne`, `jlt`, `jle`, `jgt`, `jge` - условный переход, при этом можно опционально указать вторую метку, на которую будет выполнен переход в случае не выполнения условия
* Завершение работы: команда `ret` завершает работу и возвращает результат обработки фильтра.

#### Пример программы на cBPF

Рассмотрим задачу фильтрации Ethernet-фреймов: будем принимать только фреймы, внутри которых содержатся UDP-сообщения, адресованные DNS Google по адресу `8.8.8.8`. 

```asm
filter_google_dns:
    ldh     [12]                ; 16-бит значение после двух MAC-адресов
    jne     #0x0800, fail       ; проверяем, что внутри кадра у нас IPv4-пакет
    ldb     [23]                ; 8-бит значение типа протокола в заголовке IP
    jne     #17, fail           ; 17 - это UDP, 6 - это TCP
    ld      [30]                ; 4-байтное значение IP-адреса
    jne     #0x08080808, fail   ; сравниваем с адресом 8.8.8.8
success:
    ret     #-1                 ; значение -1 == 0xFFFFFFFF
fail:
    ret     #0                  ; значение  0
```

Данная программа проверяет, что внутри Ethernet-фрейма содержится действительно IPv4-пакет, который, в свою очередь, содержит сообщение типа UDP, и адресован получателю `8.8.8.8`. Возвращаемое значение - это максимальное количество байт, которое фильтр должен пропустить. Таким образом, значение `0` означает отклонение пакета, а максимально возможное беззнаковое целочисленное значение - пропуск пакета целиком.

### Загрузка программы-фильтра в ядро 

К сокету можно прикрепить BPF-фильтр, используя системный вызов `setsockopt`:

```c
setsockopt(
    sock,         		// файловый дескриптор сокета
    SOL_SOCKET,   		// опция предназначена для сокета в целом
    SO_ATTACH_FILTER,	// команда "присоединить фильтр"
    
    // указатель на структуру, которая содержит cBPF-программу
    struct *sock_fprog program,
    // размер аргумента; требуется как generic-параметр для setsockopt
    sizeof(struct sock_fprog)
);
```

Сама структура программы состоит из двух полей: указателя на последовательность инструкций, и количество инструкций (не байт!) в программе. Каждая инструкция - это 8 байт, которые можно описать структурой `struct sock_filter`. 

Ассемблер BPF, который имеется в составе исходных текстов ядра Linux, имеет опцию для вывода байткода в формате Си-структур, и этот вывод можно включить в код препроцессором.

```bash
> linux-5.15/tools/bpf/bpf_asm -c filter.s >filter.inc
```

```c
struct sock_filter[] code = {
    #incldue "filter.inc"   
    /*
    Здесь препроцессор вставит как есть текст вывода ассемблера:
    { 0x28,  0,  0, 0x0000000c },
	{ 0x15,  0,  5, 0x00000800 },
	{ 0x30,  0,  0, 0x00000017 },
	{ 0x15,  0,  3, 0x00000011 },
	{ 0x20,  0,  0, 0x0000001e },
	{ 0x15,  0,  1, 0x08080808 },
	{ 0x06,  0,  0, 0xffffffff },
	{ 0x06,  0,  0, 0000000000 },
    */
};

struct sock_fprog program = {
    .filter = code,   // указатель на последовательность инструкций

    /* Количество инструкций можно рассчитать как размер всех
    инструкций в байтах, деленный на размер одной инструкции */
    .len = sizeof(code)/sizeof(code[0])
};
```

Загрузка программы подразумевает её обязательную проверку верификатором, который проверяет, что: 1) все инструкции в программе корректны; 2) размер программы не превышает 4096 инструкций; 3) программа не содержит циклов.

В случае отклонения программы верификатором, системный вызов `setsockopt` вернёт значение `-1`.